= PART B: Advanced Python
:doctype: book
:sectnums:
:docinfo:
:toc:

== OOP

=== Abstraction (Modeling)

Abstraction is a fundamental concept in object-oriented programming (OOP) that refers to the
process of exposing only the relevant and essential data and behavior to the users without
showing the internal implementation details. It is used to manage complexity and reduce
dependencies between classes. Abstraction is achieved by using **abstract classes** or
**interfaces**.

They key points about abstraction are:

- Focuses on the "what" an object does rather than "how" it does it
- Allows you to define a clear and high-level interface for interacting with objects
- Uses abstract classes or interfaces provide a blueprint for other classes to follow
- Manages complexity and enhances code readability

[source,python]
----
include::01_oop/examples/abstraction.py[]
----

=== Inheritance (Code Reuse)

Inheritance is the process of creating a new class from an existing class. The new class is called
the subclass or derived class. The existing class is called the superclass or base class. The
subclass inherits the attributes and methods of the superclass. Inheritance is used to reuse code
and to represent an is-a relationship, e.g a student is a person.

Key points about inheritance:

- Reuses code from an existing class
- Represents an is-a relationship

[source,python]
----
include::01_oop/examples/inheritance.py[]
----



=== Encapsulation (Data Hiding)

This is a fundamental concept in object-oriented programming (OOP) that refers to the hinding of
data through the use of access modifiers and special methods called getters and setters. It is
used to protect the internal state of an object from the outside world.

Python offers no mechanism for making attributes private and relies on naming conventions to
distinguish between public and private attributes. Protected attributes are prefixed with a single
underscore and private attributes are prefixed with a double underscore.

Key points about encapsulation:

- Uses access modifiers to hide the internal state of an object
- Provides getters and setters to access and modify the internal state of an object
- Defines protection logic for invalid values in the setters

[source,python]
----
include::01_oop/examples/encapsulation.py[]
----


Public attributes and methods are accessible from outside the class. They are used to define the
interface of the class. Typcially all getter and setter methods are public. Public attributes and
methods are not prefixed with an underscore.

Protected attributes and methods are accessible from outside the class but only in a subclass. They
may or may not have a getter or setter method. Protected attributes and methods are prefixed with
a single underscore.

Private attributes and methods are not accessible from outside the class. They are used to hide the
internal implementation details of a class. Private attributes and methods are prefixed with a
double underscore.

[source,python]
----
include::01_oop/examples/access_modifiers.py[]
----


=== Polymorphism (Flexibility)

*Polymorphism* is the ability of an object to take on many forms. It is used to represent an is-a
relationship. Polymorphism is achieved by using inheritance and overriding or overloading the
methods of the superclass.

*Overriding* is the process of redefining a method in the subclass. The method in the subclass has
the same name and signature as the method in the superclass.

*Overloading* is the process of defining multiple methods with the same name but different
signatures in the same class.

[source,python]
----
include::01_oop/examples/polymorphism.py[]
----


=== Association (Relationships)

Association represents a relationship between classes. It describes how objects from different
classes interact and collaborate to achieve a certain functionality. Associations define the ways
in which objects can relate to each other and exchange information.

Associations may have also have a direction. For example, a car has an engine, but an engine does
not have a car. This is a unidirectional association. Possible directions for associations are:

- non-directional
- uni-directional
- bi-directional

Associations may also have a multiplicity. For example, a car has one engine, but an engine may
belong multiple cars. In this case, the association is one-to-many. Possible multiplicities for
associations are:

- one-to-one
- one-to-many
- many-to-many

Key points about associations:

- Defines the ways in which objects can relate to each other and exchange information
- May have a direction (non-directional, uni-directional, bi-directional)
- May have a multiplicity (one-to-one, one-to-many, many-to-many)


==== Dependency
Dependency is a relationship between two classes in which one class depends on the other. It is
used to represent a "uses-a" relationship. For example a car can be ignited only if the owner has
the right key. In abstract terms the key is the interface and if its implementation is changed
then the car will not be able to start.

Key points about dependency:

- "Uses-A" Relationship
- Unidirectional
- Weak Coupling
- Short Lifetime


==== Composition
Composition allows you to build complex objects by combining simpler objects. It involves
creating a class that contains one or more objects of other classes as its members. In
composition, the containing class is responsible for creating and managing the objects it
contains, and it can delegate certain responsibilities to those contained objects.

While both composition and inheritance facilitate code reuse, composition is often preferred over
inheritance when you want to avoid tight coupling between classes or when the "is-a" relationship
isn't appropriate. Composition offers more flexibility and allows you to create more maintainable
code in complex scenarios.

Key points about composition:

- "Has-A", "Composed-Of" Relationship
- Delegate Responsibilities (the whole delegates responsibilities to the parts)
- Strong Coupling (the whole is responsible for the parts)
- Single Ownership (if the whole is destroyed, the parts are destroyed)
- Shared Lifetime (if one part is destroyed, the whole is destroyed)

==== Aggregation

Aggregation is another concept in object-oriented programming (OOP) that involves a "whole-part"
relationship between classes. It's a form of association where one class represents a larger
structure (the whole), and it contains or is composed of other classes (the parts). Aggregation
is a more specialized form of composition, emphasizing a looser relationship between the whole
and its parts.

While both aggregation and composition involve relationships between classes, composition implies
a stronger relationship, where the contained objects are owned and managed by the containing
object. Aggregation, on the other hand, represents a looser relationship where the parts can
exist independently.

- "Has-A" Relationship
- Delegate Responsibilities (the whole delegates responsibilities to the parts)
- Looser Coupling (the whole is not responsible for the parts)
- Shared Ownership (if the whole is destroyed, the parts are not destroyed)
- Independent Lifetimes (if one part is destroyed, the whole is not destroyed)



== SOLID

The SOLID principles are a set of design principles for software development that aim to improve
the quality of software by making it more maintainable, flexible, understandable and scalable.
They were introduced by Robert C. Martin (Uncle Bob) in his 2000 paper, Design Principles and
Design Patterns. The SOLID acronym was introduced later by Michael Feathers.

The SOLID principles are:

- Single Responsibility Principle
- Open/Closed Principle
- Liskov Substitution Principle
- Interface Segregation Principle
- Dependency Inversion Principle


=== Single Responsibility Principle
The single responsibility principle states that a class or function should have a single reason
to change. Simply put it means that a class or function should combine just one set of related
behaviors.

For example, instead of creating a single class to handle all possible protocol packet types, with
their associated parsing, validation, and serialization logic, you can create a separate class for
each packet type. This makes it easier to understand and maintain the code.

[source,python]
----
include::02_solid/examples/single_responsibility_bad.py[]
----

With some refactoring, you can split the class into several classes, each of which has a single
responsibility.

[source,python]
----
include::02_solid/examples/single_responsibility_good.py[]
----


=== Open/Closed Principle

A module, class or function should be open for extension but closed for modification. In Python, you
can use inheritance and composition to achieve this principle.

This can be achiieved through:

- Subclassing (extending existing functionality of a parent class)
- Mixin (adding new functionality to a class through multiple inheritance)
- Polymorphism (overriding existing functionality)
- Monkey patching (adding new functionality at runtime)

[source,python]
----
include::02_solid/examples/open_closed_bad.py[]
----

[source,python]
----
include::02_solid/examples/open_closed_good.py[]
----


=== Liskov Substitution Principle
The derived classes must be substitutable for their base classes. Derived classes only extend the
functionality of base classes, they do not remove any functionality. A method that behaves in a
different way for a parent class and its child classes violates this principle.

The Liskov substitution is used to ensure that class hierarchies are well designed and to prevent
unexpected behavior when using polymorphism. Some bad examples of violating this principle are:

- Base class depends on its subtype
- The code has to check the type of an object before calling a method
- Override a method of a base class to do nothing
- Overriden methods change their behavior


[source,python]
----
include::02_solid/examples/liskov_substitution_bad.py[]
----


[source,python]
----
include::02_solid/examples/liskov_substitution_good.py[]
----


=== Interface Segregation Principle
The seggregation principles is applied when a class has many subtypes and sometimes only a few
of them need to use a particular method. In this case, it is better to split the interface into
several smaller interfaces so that each subtype only implements the methods that it needs.

Code smells that indicate that the interface segregation principle is being violated:

- A class has a large number of methods
- A class has a large number of methods that are not used by all subtypes

[source,python]
----
include::02_solid/examples/interface_segregation_bad.py[]
----


[source,python]
----
include::02_solid/examples/interface_segregation_good.py[]
----


=== Dependency Inversion Principle

High-level modules should not depend on low-level modules. Both should depend
on abstractions. Abstractions should not depend on details. Details should
depend on abstractions.

[source,python]
----
include::02_solid/examples/dependency_inversion_bad.py[]
----

[source,python]
----
include::02_solid/examples/dependency_inversion_good.py[]
----

== Design Patterns

=== Creational Patterns

The creational patterns are a set of design patterns that deal with the creation of objects. They
are used to create objects in a systematic way that promotes reusability and flexibility. The
creational patterns are:

- Factory Method
- Abstract Factory
- Builder
- Prototype
- Singleton


==== Factory Method

The factory method pattern is a creational pattern that uses factory methods to create objects.
A factory method is a method that returns an object of a class and can be called at runtime. It
provides a way to hide the creation logic of an object. In Python the factory method is usually
implemented as a static method or a class method.

[source,python]
----
include::03_patterns/examples/factory_static_method.py[]
----

[source,python]
----
include::03_patterns/examples/factory_class_method.py[]
----


==== Abstract Factory

The abstract factory pattern is a creational pattern that extends the factory method pattern. It
is an abstract class that provides an interface consisting of a set of factory methods for creating
objects that are somehow related. The methods themselves are abstract and are specified to return
abstract objects.


[source,python]
----
include::03_patterns/examples/abstract_factory.py[]
----

==== Builder

The builder pattern is a creational pattern that is used to create complex objects. It provides a
way to create an object step by step and allows you to produce different types and
representations of an object using the same construction code.

In Python the builder pattern is usually implemented using a class with a **_fluent_
_interface_**. A fluent interface is an object-oriented API that aims to provide more readable code.

Typically it involves method chaining and replaces multi-parameter functions, such as complex
constructors, with multiple methods that each take a single parameter.

[source,python]
----
# Complex constructor
person = Person(
    age = 40,
    name = "John Doe",
)

# Builder with fluent interface
person = Person().name("John Doe").age(40)
----

It is implemented by using method chaining to invoke multiple methods on the same object. The
methods return the object itself which allows the calls to be chained together in a single
statement.

[source,python]
----
include::03_patterns/examples/builder.py[]
----


==== Prototype
The prototype pattern is a creational pattern that is used to create objects by cloning existing
objects. The new object will have the same properties as the cloned object but will be a separate
instance. It provides a way to hide the creation logic of an object.

In Python the prototype may be implemented using the copy module or the copy() and deepcopy()
methods. The copy() method creates a shallow copy of an object. A shallow copy of an object is a
copy of the object without cloning any of its internal references. The deepcopy() method creates a
deep copy of an object. A deep copy of an object is a copy of the object that clones all of its
internal references.

For simplicity the following will not use the copy methods and instead will show the logic of the
prototype pattern.

[source,python]
----
include::03_patterns/examples/prototype.py[]
----


==== Singleton
The singleton pattern is a creational pattern that is used to create a single instance of a class.
It provides a way to hide the creation logic of an object.

In Python the singleton pattern can be implemented in many ways, for example by using the __new__
method.

[source,python]
----
include::03_patterns/examples/singleton.py[]
----


=== Structural Patterns

Structural patterns are a set of design patterns that deal with the composition of classes and
objects. They are used to create larger structures from smaller ones. The structural patterns are:

- Adapter
- Bridge
- Composite
- Decorator
- Facade
- Flyweight
- Proxy

==== Adapter
The adapter pattern is a structural pattern that is used to adapt the interface of a class to
another interface. It provides a way to hide the incompatibility between two interfaces.  Typically
the adapter will implement the required interface and use an instance of the incompatible class
to delegate the calls to.

[source,python]
----
include::03_patterns/examples/adapter.py[]
----


==== Bridge
The bridge pattern provides a way to hide the implementation details of a class from the clients
using it.

[source,python]
----
include::03_patterns/examples/bridge.py[]
----


==== Composite
The composite pattern is a structural pattern that is used to compose objects into tree structures
to represent part-whole hierarchies. It provides a way to treat both individual objects and groups
of objects in a uniform way. It is used to create a tree structure of objects where each node in
the tree structure can be either an individual object or a group of objects.

[source,python]
----
include::03_patterns/examples/composite.py[]
----

==== Decorator
The decorator pattern is a structural pattern that is used to add new functionality to an existing
object without changing its structure. It provides a way to extend the functionality of an object
at runtime.

[source,python]
----
include::03_patterns/examples/decorator.py[]
----


==== Facade
The facade pattern is a structural pattern that is used to provide a unified interface to a set of
interfaces in a subsystem. It provides a way to hide the complexity of a subsystem from its
clients. It is used to create a simplified interface to a complex system.

[source,python]
----
include::03_patterns/examples/facade.py[]
----


==== Flyweight
The flyweight pattern is a structural pattern that is used to minimize memory usage and improve
the performance of an application by sharing as much data as possible with other similar objects.
It provides a way to share objects that are used in multiple contexts at the same time. It is used
to create a large number of similar objects efficiently.

[source,python]
----
include::03_patterns/examples/flyweight.py[]
----


==== Proxy
The proxy pattern is a structural pattern that is used to provide a surrogate or placeholder for
another object to control access to it. It provides a way to add extra functionality to an object
without changing its structure.

[source,python]
----
include::03_patterns/examples/proxy.py[]
----


=== Behavioral Patterns

Behavioral patterns are a set of design patterns that deal with the communication between classes
and objects. They are used to define how objects interact with each other. The behavioral patterns
are:

- Chain of Responsibility
- Command
- Interpreter
- Iterator
- Mediator
- Memento
- Observer
- State
- Strategy
- Template Method
- Visitor

==== Chain of Responsibility
==== Command
==== Interpreter
==== Iterator
==== Mediator
==== Memento
==== Observer
==== State
==== Strategy
==== Template Method
==== Visitor


== Software Architecture

=== Multilayered
This pattern can be used to structure programs that can be decomposed into groups of subtasks,
each of which is at a particular level of abstraction. Each layer provides services to the next
higher layer.

Examples:

- OSI model
- Model-View-Controller (MVC)
- Model-View-ViewModel (MVVM)
- Model-View-Presenter (MVP)
- Model-View-Intent (MVI)
- Model-View-Update (MVU)

=== Monolithic
This pattern can be used to structure programs that can be decomposed into a set of modules that
are tightly coupled and run in the same process. Monolithic applications are typically deployed as
a single unit.

Links:

- https://en.wikipedia.org/wiki/Monolithic_application[Monolithic application]
- https://en.wikipedia.org/wiki/Monolithic_kernel[Monolithic kernel]


=== Service-Oriented
This pattern can be used to structure programs that can be decomposed into a set of services that
are independently deployable and scalable. Each service is self-contained and implements a single
business capability. Services communicate with each other using a protocol such as HTTP/HTTPS or
gRPC. Services can be deployed as containers in a container orchestration platform such as
Kubernetes. Microservices are typically implemented using a framework such as Spring Boot. The
https://microservices.io/[microservices.io] website provides a good overview of microservices.

Examples:

- https://spring.io/projects/spring-boot[Spring Boot]
- https://quarkus.io/[Quarkus]
- https://micronaut.io/[Micronaut]
- https://helidon.io/[Helidon]
- https://www.mulesoft.com/platform/mule[MuleSoft]
- https://www.ibm.com/cloud/microservices[IBM Cloud Microservices]
- https://www.redhat.com/en/technologies/jboss-middleware/microservices[Red Hat JBoss Middleware]
- https://www.nginx.com/products/nginx/kubernetes-ingress-controller/[NGINX Kubernetes Ingress Controller]


=== Client-Server
This pattern can be used to structure programs that can be decomposed into two parts: a server
that provides a service, and a client that requests services from the server. The server component
is usually designed to be reusable. The client and server communicate with each other using a
protocol.

Examples:

- Web service (SOAP, REST)
- Remote procedure call (RPC)

=== Publish-Subscribe
This pattern can be used to structure programs that can be decomposed into a set of publishers
and subscribers that communicate with each other using a message broker. Publishers publish events
to the message broker, and subscribers subscribe to events of interest to them. The message broker
acts as an intermediary between publishers and subscribers.

Examples:

- https://kafka.apache.org/[Apache Kafka] (event streaming platform)
- https://pulsar.apache.org/[Apache Pulsar] (event streaming platform)
- https://www.confluent.io/[Confluent] (event streaming platform)
- https://nats.io/[NATS] (event streaming platform)
- https://www.rabbitmq.com/[RabbitMQ] (message broker)
- https://mosquitto.org/[Mosquitto] (message broker)
- https://zeromq.org/[ZeroMQ] (messaging library)
- https://redis.io/[Redis] (in-memory data structure store)

Links:

- https://en.wikipedia.org/wiki/Event_loop[Event loop]
- https://en.wikipedia.org/wiki/Event-driven_architecture[Event-driven architecture]
- https://en.wikipedia.org/wiki/Event-driven_programming[Event-driven programming]
- https://en.wikipedia.org/wiki/Event_stream_processing[Event stream processing]
- https://en.wikipedia.org/wiki/Event-driven_SOA[Event-driven SOA]
- https://luckyresistor.me/2019/07/05/event-based-firmware-1/[Event-driven firmware]


=== Peer-to-Peer
This pattern can be used to structure programs that can be decomposed into a set of peers
that are symmetric in terms of their functionality, and each peer may act as both a client
and a server. Blockchains or torrents are examples of peer-to-peer networks.

Examples:

- Blockchain
- BitTorrent


=== Pipe-Filter
This pattern can be used to structure programs that can be decomposed into a set of filters
that process a stream of data, and a set of pipes that connect the filters together. Each
filter has a single input and a single output. Pipes can be used to connect the filters
together and to connect a filter to a data source or data sink.

Examples:

- https://en.wikipedia.org/wiki/Pipeline_(Unix)[Unix pipelines]
- https://beam.apache.org/documentation/programming-guide/[Apache Beam]


== Logging

=== Logger Objects
=== Logging Configuration
=== Logging Levels
=== Logging Handlers
=== Logging Formatters
=== Logging Filters
=== Logging Best Practices


== Exception Handling

=== Exception Hierarchy
=== Exception Handling
=== Exception Propagation
=== Exception Chaining
=== Exception Best Practices

== Dunder Methods
Dunder methods are special methods that are defined using the double underscore notation. They are
used to emulate the behavior of built-in types and provide a way to customize the behavior of
classes. Dunder methods are also called magic methods. Some of the most common use cases for
dunder methods are:

- Emulate the behavior of built-in types
- Customize the behavior of classes
- Object representation
- Implement operator overloading
- Implement iterators
- Implement context managers

=== Object representation

[options="header"]
|====
|Representation | Dunder method | Notes

|Human-readable | `\\__str__` | If you want to provide a human-readable string representation of an
object, use the `\__str__` method. This method should return a string that is easy for a human to
understand.

|Unambiguous | `\\__repr__` | If you want to provide an unambiguous string representation of an
object, use the `\__repr__` method. This method should return a string that can be used to
recreate the object.

|Custom formatting | `\\__format__` | If you want to provide custom string formatting of an object, use
the `\__format__` method. This method should return a string that is formatted according to the
format specification.

|Raw byte string | `\\__bytes__` | If you want to provide a raw byte string representation of an
object, use the `\__bytes__` method. This method should return a byte string that can be used to
recreate the object. This method is used by the bytes() function.

|Unique | `\\__hash__` | If you want to compute the hash of an object, use the `\__hash__` method.
This method should return an integer that is used to compare objects in dictionaries and sets.
This method is used by the hash() function.

|====

[source,python]
----
include::07_dunder/examples/dunder_object_representation.py[]
----


=== Custom behavior of classes and instances

[options="header"]
|====
|Behavior | Dunder method | Notes

|Customize creation | `\\__new__` | If you want to customize the creation of an instance, use the
`\__new__` method. This method should return an instance of the class. It is used to create the
instance before it is initialized.

|Customize initialization | `\\__init__` | If you want to customize the initialization of an
instance, use the `\__init__` method. This method is called right after the instance has been
created. It is used to initialize the instance variables of the class.

|Customize calling | `\\__call__` | If you want to customize the behavior of calling an instance,
use the `\__call__` method. This method is called when the instance is called like a function.

|Customize deletion | `\\__del__` | If you want to customize the deletion of an instance, use the
`\__del__` method. This method is called when the instance is deleted. It is used by the del
statement.

|====


[source,python]
----
include::07_dunder/examples/dunder_customize_behavior.py[]
----


=== Custom behavior of built-in types

[options="header"]
|====
|Built-in type | Dunder method | Notes

|`int()` | `\\__int__` | If you want to convert an object to an integer, use the `\__int__`
method. This method should return an integer. It is used by the int() function.

|`float()` | `\\__float__` | If you want to convert an object to a float, use the `\__float__`
method. This method should return a float. It is used by the float() function.

|`complex()` | `\\__complex__` | If you want to convert an object to a complex number, use the
`\__complex__` method. This method should return a complex number. It is used by the complex()
function.

|`bool()` | `\\__bool__` | If you want to evaluate the truth value of an object, use the
`\__bool__` method. This method should return a boolean. It is used by the bool() function.

|====


[source,python]
----
include::07_dunder/examples/dunder_builtin_types.py[]
----


=== Operator overloading

[options="header"]
|===================
|Operator | Dunder method

|`==` | `\\__eq__`
|`!=` | `\\__ne__`
|`<` | `\\__lt__`
|`<=` | `\\__le__`
|`>` | `\\__gt__`
|`>=` | `\\__ge__`
|`+` | `\\__add__`
|`-` | `\\__sub__`
|`*` | `\\__mul__`
|`/` | `\\__truediv__`
|`//` | `\\__floordiv__`
|`%` | `\\__mod__`
|`**` | `\\__pow__`
|`&` | `\\__and__`
|`|` | `\\__or__`
|`^` | `\\__xor__`
|`<<` | `\\__lshift__`
|`>>` | `\\__rshift__`
|`+=` | `\\__iadd__`
|`-=` | `\\__isub__`
|`*=` | `\\__imul__`
|`/=` | `\\__itruediv__`
|`//=` | `\\__ifloordiv__`
|`%=` | `\\__imod__`
|`**=` | `\\__ipow__`
|`&=` | `\\__iand__`
|`|=` | `\\__ior__`
|`^=` | `\\__ixor__`
|`<<=` | `\\__ilshift__`
|`>>=` | `\\__irshift__`
|`-` | `\\__neg__`
|`+` | `\\__pos__`
|`~` | `\\__invert__`
|===================

[source,python]
----
include::07_dunder/examples/dunder_operator_overloading.py[]
----

=== Iterator protocol

[options="header"]
|====
|Function | Dunder method | Notes

|Create iterator | `\\__iter__` | If you want to iterate over an object, use the `\__iter__` method.
This method should return an iterator. It is used by the iter() function.

|Get next item  | `\\__next__` | If you want to get the next value of an iterator, use the
`\__next__`
method. This method should return the next value of the iterator. It is used by the next().

|====

[source,python]
----
include::07_dunder/examples/dunder_iterator_protocol.py[]
----

=== Context manager protocol

[options="header"]
|====
|Function | Dunder method | Notes

|Enter context | `\\__enter__` | If you want to customize the behavior of the `with` statement
when entering the block, use the `\__enter__` method. This method should return an object that
will be assigned to the variable in the `with` statement.

|Exit context  | `\\__exit__` | If you want to customize the behavior of the `with` statement
when exiting the block, use the `\__exit__` method. This method should return a boolean that
indicates whether the exception was handled or not.

|====

[source,python]
----
include::07_dunder/examples/dunder_context_manager.py[]
----

== Advanced Collections

=== Data Manipulation

==== map
==== filter
==== reduce
==== reverse
==== sort


==== pack
The packing is done by using the zip() function. The zip() function is used to pack two or more
iterables into a single iterable. It is used to pack two or more lists into a single list. It is
used to pack two or more tuples into a single tuple. It is used to pack two or more dictionaries
into a single dictionary.


==== unpack
The unpacking is done by using the `*` operator. The `*` operator is used to unpack an iterable into
a sequence of arguments. It is used to unpack a list into a sequence of arguments. It is used to
unpack a tuple into a sequence of arguments. It is used to unpack a dictionary into a sequence of
arguments.

==== bisect
Bisect is a module that provides functions for manipulating sorted lists. It provides functions for inserting items into a sorted list and for finding items in a sorted list. It also provides functions for manipulating sorted lists in place.

==== copy
Copy is a module that provides functions for copying objects. It provides functions for copying objects by value and by reference. It also provides functions for copying objects by value and by reference.

==== struct
Struct is a module that provides functions for converting between strings and binary data. It provides functions for packing and unpacking binary data. It also provides functions for converting between strings and binary data.

=== Data Structures

==== array
==== namedtuple
==== defaultdict
==== types
==== queue
==== deque
==== enum
==== weakref
==== heapq
==== dataclasses

==== Counter
==== ChainMap
==== OrderedDict

== Import System

=== Absolute Imports

Absolute imports are imports that use the full path of a module. Absolute imports are the
preferred way of importing modules. Absolute imports are more readable and less error-prone than
relative imports. Absolute imports are also faster than relative imports. Absolute imports are
enabled by default in Python 3.

The disadvantage of absolute imports is that they are not portable. Absolute imports are not
suitable for code that needs to run from different folder locations.

=== Relative Imports

The advantage of relative imports is that they are portable. Relative imports are suitable for
code that needs to run from different folder locations.

=== Modules

A module is a file that contains Python code. A module can be imported using the import statement.
The import statement searches for modules in the following locations:

- The current directory
- The PYTHONPATH environment variable
- The installation-dependent default

The search path can be modified at runtime using the sys.path variable. The sys.path variable is
a list of strings that specifies the search path for modules.

=== Packages

A package is a collection of modules that are grouped together in a directory. A package is a
module with a __path__ attribute. The __path__ attribute is a list of strings that specifies the
search path for modules in the package. The search path is initialized from the following sources:

- The __path__ attribute of the parent package
- The PYTHONPATH environment variable
- The installation-dependent default


=== Namespace Packages

A namespace package is a package that is split across multiple directories. A namespace package
is a package with a __path__ attribute that is a list of strings. Each string in the __path__
attribute is the path to a directory that contains a part of the package. A namespace package
is created by placing a __init__.py file in each directory that contains a part of the package.
The __path__ attribute is initialized from the following sources:

- The __path__ attribute of the parent package
- The PYTHONPATH environment variable
- The installation-dependent default


=== Importlib

The importlib module provides functions for programmatically importing modules. The importlib
module also provides functions for creating custom importers. An importer is an object that is
responsible for finding and loading modules.

=== Import Hooks

An import hook is a function that is called when a module is imported. An import hook can be used
to customize the import process. The importlib module provides functions for registering import
hooks. The importlib module also provides functions for creating custom importers. An importer
is an object that is responsible for finding and loading modules. The importlib module provides
the following importers:

- BuiltinImporter
- FrozenImporter
- MetaPathFinder
- PathEntryFinder
- FileFinder
- SourceFileLoader
- SourcelessFileLoader
- ExtensionFileLoader
- FileLoader
- SourcelessFileLoader


== Testing

Python has a rich ecosystem of testing frameworks and tools. The following are some of the most
popular testing frameworks and tools:

- https://docs.pytest.org/[pytest]
- https://docs.python.org/3/library/unittest.html[unittest]
- https://docs.python.org/3/library/doctest.html[doctest]
- https://docs.python.org/3/library/unittest.mock.html[unittest.mock]
- https://coverage.readthedocs.io/[Coverage]
- https://hypothesis.readthedocs.io/[Hypothesis]
- https://tox.readthedocs.io/[tox]

=== pytest

pytest is a popular testing framework that makes it easy to write simple and scalable tests. It
provides a rich set of features for writing and running tests, including: fixtures, parameterized
tests, test discovery, test collection, test execution, test reporting, and test debugging.

=== unittest

unittest is a testing framework that is part of the Python standard library. It provides a rich
set of features for writing and running tests, including: fixtures, parameterized tests, test
discovery, test collection, test execution, test reporting, and test debugging.

=== doctest

doctest is a testing framework that is part of the Python standard library. It provides a simple
and lightweight way of testing code by embedding tests in docstrings. It is useful for testing
examples in documentation.

=== unittest.mock

unittest.mock is a testing framework that is part of the Python standard library. It provides a
rich set of features for mocking objects and functions, including: mocking, patching, stubbing,
spying, and faking.

=== Coverage

Coverage is a tool for measuring code coverage of Python programs. It can be used to identify
untested parts of a program. It can also be used to measure the effectiveness of a test suite. It
can be used as a command-line tool or as a library. It can be used with pytest, unittest, and
doctest.

=== Hypothesis

Hypothesis is a library for property-based testing. It can be used to generate test data and
assertions. It can be used with pytest, unittest, and doctest.

=== tox

tox is a tool for testing Python programs in multiple environments. It can be used to test
programs in different versions of Python and different operating systems. It can be used as a
command-line tool or as a library. It can be used with pytest, unittest, and doctest


== Tracing

The tracing module provides functions for tracing the execution of Python programs. It can be used
to trace the execution of functions, methods, and classes. How to use the tracing module:

- Import the tracing module
- Create a tracer object
- Register the tracer object with the tracing module
- Run the program
- View the trace output


== Profiling

Profiling is a technique for measuring the performance of a program. It can be used to identify the
bottlenecks in a program and to optimize the performance of a program. The profiling module provides
functions for profiling the execution of Python programs. It can be used to profile the execution
of functions, methods, and classes. How to use the profiling module:

- Import the profiling module
- Create a profiler object
- Register the profiler object with the profiling module
- Run the program
- View the profile output








